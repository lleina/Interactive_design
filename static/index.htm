<html>

<head>
    <!---Imports d3 and topojson --->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <div id="filter-mode">
        select filter mode:
        <label><input type="radio" name="filterMode" value="all" checked> ALL</label>
        <label><input type="radio" name="filterMode" value="or"> OR</label>
        <label><input type="radio" name="filterMode" value="and"> AND</label>
    </div>

    <div id="type-selection">
        <div>Select Types:</div>
        <!-- Dynamically populate types as checkboxes -->
    </div>


    <style>
        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;
        }

        .tooltip {
            position: absolute;
            text-align: left;
            width: 200px;
            height: auto;
            padding: 10px;
            font: 12px sans-serif;
            background: rgba(255, 255, 255, 0.9);
            border: solid 1px #aaa;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
        }

        #type-selection input[type='checkbox']:disabled+label {
            color: #999;

            cursor: not-allowed;
        }
    </style>
</head>

<body>
    <h3>
        Leina Li (ll736), Aditya Manthri (anm97)
    </h3>
    <svg id="scattersvg" height="600" width="600"></svg>
    <svg id="comparesvg" height="600" width="600" style="border:1px solid black"></svg>
    <script>
        const scatsvg = d3.select("svg#scattersvg");
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
        width = scatsvg.attr("width");
        height = scatsvg.attr("height");
        const margins = { top: 50, right: 20, bottom: 70, left: 70 };
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;
        let selectedPoints = [];


        var comparisonDiv = d3.select("body").append("div")
            .attr("class", "comparison")
            .style("opacity", 0);

        var dataset;
        d3.csv('./pokedex.csv', d3.autoType)
            .then((data) => {

                dataset = data;

                yExtent = d3.extent(data, d => d['Total']);
                xExtent = d3.extent(data, d => d['Generation']);
                typeExtent = [];
                data.forEach(function (d) {
                    if (!typeExtent.includes(d['Type I'])) {
                        typeExtent.push(d['Type I']);
                    }
                });
                console.log(typeExtent)

                const typeSelectionDiv = d3.select("#type-selection");
                typeExtent.forEach(function (type) {
                    typeSelectionDiv.append("label")
                        .text(type)
                        .append("input")
                        .attr("type", "checkbox")
                        .attr("name", "type")
                        .attr("value", type)
                        .style("margin-left", "5px")
                        .style("margin-right", "15px");
                });
                yScale = d3.scaleLinear().domain(yExtent).range([chartHeight, 0]);
                xScale = d3.scaleLinear().domain(xExtent).range([0, chartWidth]);
                colors = [
                    "#7AC74C", // Grass
                    "#EE8130", // Fire
                    "#6390F0", // Water
                    "#A6B91A", // Bug
                    "#A8A77A", // Normal
                    "#A33EA1", // Poison
                    "#F7D02C", // Electric
                    "#E2BF65", // Ground
                    "#D685AD", // Fairy
                    "#C22E28", // Fighting
                    "#F95587", // Psychic
                    "#B6A136", // Rock
                    "#735797", // Ghost
                    "#96D9D6", // Ice
                    "#6F35FC", // Dragon
                    "#705746", // Dark
                    "#B7B7CE", // Steel
                    "#A98FF3"  // Flying
                ];
                const typeScale = d3.scaleOrdinal().domain(typeExtent).range(colors);
                let chartArea = scatsvg.append('g')
                    .attr('transform', `translate(${margins.left}, ${margins.top})`);

                let leftAxis = d3.axisLeft(yScale);
                scatsvg.append('g')
                    .attr('class', 'y axis')
                    .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                    .call(leftAxis);

                let bottomAxis = d3.axisBottom(xScale)
                    .tickFormat(d3.format(".0f"))
                    .ticks(9)
                let element = scatsvg.append('g')
                    .attr('class', 'y axis')
                    .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                    .call(bottomAxis);

                let leftGridlines = d3.axisLeft(yScale)
                    .tickSize(-chartWidth - 10)
                    .tickFormat('');
                scatsvg.append('g').attr('class', 'gridlines')
                    .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                    .call(leftGridlines)

                let bottomGridlines = d3.axisBottom(xScale)
                    .tickSize(-chartHeight - 10)
                    .tickFormat('')
                    .ticks(9);
                scatsvg.append('g').attr('class', 'gridlines')
                    .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                    .call(bottomGridlines);

                scatsvg.append("text")
                    .attr("class", "x-axis-title")
                    .attr("x", chartWidth / 2 + 50)
                    .attr("y", chartHeight + 100)
                    .attr("text-anchor", "middle")
                    .text("Generation");


                scatsvg.append("text")
                    .attr("class", "y-axis-title")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -chartHeight / 2 - 50)
                    .attr("y", 20)
                    .attr("text-anchor", "middle")
                    .text("Base Stats Total");

                scatsvg.append("text")
                    .attr("class", "chart-title")
                    .attr("x", chartWidth / 2 + 40)
                    .attr("y", 30)
                    .attr("text-anchor", "middle")
                    .style("font-weight", "bold")
                    .style("font-size", "20px")
                    .style("fill", "black")
                    .text("Change of Pokemon's BST over Pokemon Generations");

                chartArea.selectAll('circle')
                    .data(data)
                    .enter().append('circle')
                    .attr('cx', d => xScale(d['Generation']) + (Math.random() - 0.5) * 10) // Jitter in the X direction
                    .attr('cy', d => yScale(d['Total']))
                    .attr('r', '5px')
                    .attr('opacity', 0.5)
                    .style('fill', function (d) { return typeScale(d['Type I']); })
                    // When setting the position of each circle, add a small random value
                    .on("click", toggleSelection)
                    .on("mouseover", showTooltip)
                    .on("mouseout", unshowtooltip);


                d3.selectAll("#type-selection input[type='checkbox'], #filter-mode input[type='radio']")
                    .on("change", function () {
                        updateChart();
                    });
                //start of page want it disabled;
                d3.selectAll("#type-selection input[type='checkbox']")
                    .property('disabled', true);

                function updateChart() {
                    const selectedTypes = d3.selectAll("#type-selection input[type='checkbox']:checked").nodes().map(el => el.value);
                    const filterMode = d3.select("#filter-mode input[type='radio']:checked").node().value;

                    let filteredData;
                    if (filterMode === "or") {
                        d3.selectAll("#type-selection input[type='checkbox']").property('disabled', false);
                        filteredData = dataset.filter(d => selectedTypes.includes(d['Type I']) || selectedTypes.includes(d['Type II']));
                    } else if (filterMode === "and") {
                        d3.selectAll("#type-selection input[type='checkbox']").property('disabled', false);
                        if (selectedTypes.length === 0) {
                            // Show nothin
                            filteredData = {};
                        } else if (selectedTypes.length === 1) {
                            // Show data where either 'Type I' or 'Type II' matches the selected type
                            filteredData = dataset.filter(d => selectedTypes.includes(d['Type I']) || selectedTypes.includes(d['Type II']));
                        } else {
                            // Show data where both 'Type I' and 'Type II' match the selected types
                            filteredData = dataset.filter(d => selectedTypes.includes(d['Type I']) && selectedTypes.includes(d['Type II']));
                        }
                    } else if (filterMode === "all") {
                        d3.selectAll("#type-selection input[type='checkbox']").property('disabled', true);
                        filteredData = dataset;
                    }

                    // Bind filtered data to circles
                    const circles = chartArea.selectAll("circle")
                        .data(filteredData, d => d.Pokemon); // Use Pokemon name as a key for object constancy

                    // Enter selection: Create new circles for new data elements
                    circles.enter().append("circle")
                        .attr('cx', d => xScale(d['Generation']) + (Math.random() - 0.5) * 20) // Apply jittering if needed
                        .attr('cy', d => yScale(d['Total']) + (Math.random() - 0.5) * 20)
                        .attr('r', d => {
                            const isSelected = selectedPoints.some(p => p.Pokemon === d.Pokemon);
                            return isSelected ? 15 : 5;
                        })
                        .style('stroke', d => {
                            const isSelected = selectedPoints.some(p => p.Pokemon === d.Pokemon);
                            return isSelected ? 'black' : 'none'
                        })
                        .style('stroke-width', 3)
                        .attr('opacity', d => {
                            const isSelected = selectedPoints.some(p => p.Pokemon === d.Pokemon);
                            return isSelected ? 0.8 : 0.5
                        })
                        .style('fill', d => typeScale(d['Type I']))
                        .merge(circles) // Merge enter and update selections
                        .on("mouseover", showTooltip)
                        .on("mouseout", unshowtooltip)
                        .on("click", toggleSelection);

                    // Update selection: Update attributes of existing circles
                    circles
                        .attr('cx', d => xScale(d['Generation']) + (Math.random() - 0.5) * 20)
                        .attr('cy', d => yScale(d['Total']) + (Math.random() - 0.5) * 20)
                        .style('fill', d => typeScale(d['Type I'])); // If you want to update the fill based on the filter

                    // Exit selection: Remove circles that no longer match the filter
                    circles.exit().remove();
                }

                function showTooltip(event, d) {
                    // Define stats and maximum value for scaling the bars
                    const stats = [
                        { name: 'HP', value: d['HP'] },
                        { name: 'Attack', value: d['Atk'] },
                        { name: 'Defense', value: d['Def'] },
                        { name: 'Sp. Atk', value: d['SpA'] },
                        { name: 'Sp. Def', value: d['SpD'] },
                        { name: 'Speed', value: d['Spe'] }
                    ];
                    const maxStatValue = 255;

                    // Convert Pokémon name to match the URL format (assuming names are already standardized in your dataset)
                    let pokemonNameForUrl = d['Pokemon'].toLowerCase().replace(/ /g, '-');

                    // Construct the sprite URL
                    let spriteUrl = `https://img.pokemondb.net/sprites/home/normal/${pokemonNameForUrl}.png`;

                    // Start building the tooltip content with Pokémon name, types, and sprite
                    let tooltipHtml = `<strong>${d['Pokemon']}</strong><br/>
                                                    <img src="${spriteUrl}" alt="${d['Pokemon']}" style="width:100px; height:100px;"><br/>
                                                    Type: ${d['Type I']}` + (d['Type II'] ? `, ${d['Type II']}` : "") + `<br/>`;


                    // Add an SVG container for the stats bar chart
                    tooltipHtml += `<svg width="200" height="${stats.length * 20}" xmlns="http://www.w3.org/2000/svg">`;

                    // Generate bars for each stat
                    stats.forEach((stat, index) => {
                        const barWidth = (stat.value / maxStatValue) * 180; // Scale bar width
                        tooltipHtml += `<text x="0" y="${index * 20 + 15}" font-size="10">${stat.name}</text>`;
                        tooltipHtml += `<rect x="50" y="${index * 20 + 10}" width="${barWidth}" height="10" style="fill:steelblue;"></rect>`;
                        tooltipHtml += `<text x="${barWidth + 55}" y="${index * 20 + 15}" font-size="10">${stat.value}</text>`;
                    });

                    tooltipHtml += `</svg>`;

                    // Display the tooltip
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(tooltipHtml)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");

                    // console.log(selectedPoints)
                    // console.log(this)
                    if (!selectedPoints.includes(d)) {
                        d3.select(this)
                            .attr("opacity", 1)
                            .attr("r", "8px")
                            .style('stroke', 'black')
                            .style('stroke-width', 3);
                    }
                }

                function unshowtooltip(event, d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                    if (!selectedPoints.includes(d)) {
                        d3.select(this)
                            .attr("r", "5px")
                            .attr("opacity", 0.5)
                            .style('stroke', "none")
                    }
                }

                function toggleSelection(event, d) {
                    const index = selectedPoints.findIndex(p => p.Pokemon === d.Pokemon);
                    if (index > -1) {
                        selectedPoints.splice(index, 1); // seselect if alrdy selected
                        d3.select(this)
                            .attr("r", "5px")
                            .attr("opacity", 0.5)
                            .style('stroke', 'none');
                    } else {
                        if (selectedPoints.length < 2) {
                            selectedPoints.push(d); // select if not alrdy selected and < 2 selected
                            d3.select(this)
                                .attr("r", "15px")
                                .attr("opacity", 0.8)
                                .style('stroke', 'black')
                                .style('stroke-width', 3);
                        }
                    }
                    compsvg.selectAll("text.Instructions")
                        .remove()
                    if (selectedPoints.length < 2) {
                        compsvg.append("text")
                            .attr("class", "Instructions")
                            .attr("x", compWidth / 2)
                            .attr("y", 20)
                            .attr("text-anchor", "middle")
                            .style("fill", "black")
                            .style("font-size", "15px")
                            .style("font-weight", "bold")
                            .text("Select up to two points to compare")
                    }
                    console.log(selectedPoints[0]);
                    update_comp();
                }

                const compsvg = d3.select("svg#comparesvg");
                compwidth = compsvg.attr("width");
                compheight = compsvg.attr("height");
                const compMargin = { top: 50, right: 20, bottom: 70, left: 70 };
                const compWidth = compwidth - compMargin.left - compMargin.right;
                const compHeight = compheight - compMargin.top - compMargin.bottom;

                if (selectedPoints.length < 2) {
                    compsvg.append("text")
                        .attr("class", "Instructions")
                        .attr("x", compWidth / 2)
                        .attr("y", 20)
                        .attr("text-anchor", "middle")
                        .style("fill", "black")
                        .style("font-size", "15px")
                        .style("font-weight", "bold")
                        .text("Select up to two points to compare");
                }

                let selectedPokemons = d3.map(selectedPoints, d => d['Pokemon']);
                const botScale = d3.scaleBand().domain(selectedPokemons).range([0, compWidth / 3 - 50])
                    .padding(0.05);

                // create HP Chart
                let hpAnnot = compsvg.append("g").attr("id", "hpA");
                const hpChart = compsvg.append("g")
                    .attr("transform", "translate(" + (compMargin.left + 5) + "," + compMargin.top + ")")
                    .attr("id", "HP");
                let hpExtent = d3.extent(data, d => d['HP']);
                let hpScale = d3.scaleLinear().domain(hpExtent).range([compHeight, 0])
                let hpAxis = d3.axisLeft(hpScale).tickSize(0);
                let hpGrid = d3.axisLeft(hpScale).tickSize(-compWidth / 3 + 50).tickFormat("");
                let hpBottomAxis = d3.axisBottom();
                let hpBottomAxisG = hpAnnot.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(${compMargin.left},${compHeight + compMargin.top})`)
                hpAnnot.append("g")
                    .attr("transform", "translate(" + (compMargin.left) + "," + compMargin.top + ")")
                    .call(hpAxis)
                hpAnnot.append("g")
                    .attr("class", "gridlines")
                    .attr("transform", "translate(" + (compMargin.left) + "," + compMargin.top + ")")
                    .call(hpGrid)
                hpBottomAxis.scale(botScale)
                hpBottomAxisG.transition().call(hpBottomAxis);

                // create Attack Chart
                let atkAnnot = compsvg.append("g").attr("id", "attackA")
                let atkExtent = d3.extent(data, d => d['Atk']);
                let atkScale = d3.scaleLinear().domain(atkExtent).range([compHeight, 0])
                let atkAxis = d3.axisLeft(atkScale).tickSize(0);
                let atkGrid = d3.axisLeft(atkScale).tickSize(-compWidth / 3 + 50).tickFormat("");
                let atkBottomAxis = d3.axisBottom();
                let atkBottomAxisG = atkAnnot.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(${compMargin.left + compWidth / 3},${compHeight + compMargin.top})`)
                atkAnnot.append("g")
                    .attr("transform", "translate(" + (compMargin.left + compWidth / 3) + "," + compMargin.top + ")")
                    .call(atkAxis)
                atkAnnot.append("g")
                    .attr("class", "gridlines")
                    .attr("transform", "translate(" + (compMargin.left + compWidth / 3) + "," + compMargin.top + ")")
                    .call(atkGrid)
                atkBottomAxisG.transition().call(hpBottomAxis);

                // create defense chart
                let defAnnot = compsvg.append("g").attr("id", "defenseA")
                const atkChart = compsvg.append("g")
                    .attr("transform", "translate(" + (compMargin.left + compWidth / 3 + 5) + "," + compMargin.top + ")")
                    .attr("id", "Attack");
                const defChart = compsvg.append("g")
                    .attr("transform", "translate(" + (compMargin.left + 2 * compWidth / 3 + 5) + "," + compMargin.top + ")")
                    .attr("id", "Defense");
                let defExtent = d3.extent(data, d => d['Def']);
                let defScale = d3.scaleLinear().domain(defExtent).range([compHeight, 0])
                let defAxis = d3.axisLeft(defScale).tickSize(0);
                let defGrid = d3.axisLeft(defScale).tickSize(-compWidth / 3 + 50).tickFormat("");
                let defBottomAxis = d3.axisBottom();
                let defBottomAxisG = defAnnot.append("g")
                    .attr("class", "x axis")
                    .attr("transform", `translate(${compMargin.left + 2 * compWidth / 3},${compHeight + compMargin.top})`)
                defAnnot.append("g")
                    .attr("transform", "translate(" + (compMargin.left + 2 * compWidth / 3) + "," + compMargin.top + ")")
                    .call(defAxis)
                defAnnot.append("g")
                    .attr("class", "gridlines")
                    .attr("transform", "translate(" + (compMargin.left + 2 * compWidth / 3) + "," + compMargin.top + ")")
                    .call(defGrid)
                defBottomAxisG.transition().call(hpBottomAxis);


                // console.log("MIIAOOO")
                // console.log(selectedPoints)
                // console.log("wooof")

                function bar_creator(xChart, scaler, extenter, bottomscaller) {
                    xChart.selectAll('rect').data(selectedPoints)
                        .join(enter => enter.append('rect')
                            .attr("fill", d => typeScale(d['Type I']))
                            .attr("x", d => bottomscaller(d['Pokemon']))
                            .attr("y", d => scaler(d['HP']))
                            .attr("height", d => scaler(extenter[0]) - scaler(d['HP']))
                            .attr("width", bottomscaller.bandwidth())
                            .attr("opacity", 0) // Set opacity low, then animate to 1 to make them fade in
                            .call(enter => enter.transition()
                                .attr('opacity', 1)),
                            update => update.call(update => update.transition()  // Animate resizing and movement
                                .attr("fill", d => typeScale(d['Type I']))
                                .attr("x", d => bottomscaller(d['Pokemon']))
                                .attr("y", d => scaler(d['HP']))
                                .attr("height", d => scaler(extenter[0]) - scaler(d['HP']))
                                .attr("width", bottomscaller.bandwidth()))
                                .attr("opacity", 1),
                            exit => exit.call(exit => exit.transition().attr('opacity', 0).remove())) // Animate opacity to fade out
                }

                function update_comp() {
                    let selectedPokemons = d3.map(selectedPoints, d => d['Pokemon']);
                    const botScale = d3.scaleBand().domain(selectedPokemons).range([0, compWidth / 3 - 50])
                        .padding(0.05);

                    hpBottomAxis.scale(botScale)
                    hpBottomAxisG.transition().call(hpBottomAxis); // all x axes use the same values
                    atkBottomAxisG.transition().call(hpBottomAxis);
                    defBottomAxisG.transition().call(hpBottomAxis);

                    bar_creator(hpChart, hpScale, hpExtent, botScale)
                    bar_creator(defChart, defScale, defExtent, botScale)
                    bar_creator(atkChart, atkScale, atkExtent, botScale)

                }

                chartArea.raise()



            });

    </script>
</body>

</html>