<html>

<head>
    <!---Imports d3 and topojson --->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>

    <div id="filter-mode">
        select filter mode:
        <label><input type="radio" name="filterMode" value="all" checked> ALL</label>
        <label><input type="radio" name="filterMode" value="or"> OR</label>
        <label><input type="radio" name="filterMode" value="and"> AND</label>
    </div>

    <div id="type-selection">
        <div>Select Types:</div>

        <!-- Dynamically populate types as checkboxes -->

    </div>


    <style>
        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;
        }

        .tooltip {
            position: absolute;
            text-align: left;
            width: 200px;
            height: auto;
            padding: 10px;
            font: 12px sans-serif;
            background: rgba(255, 255, 255, 0.9);
            border: solid 1px #aaa;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
        }

        #type-selection input[type='checkbox']:disabled+label {
            color: #999;

            cursor: not-allowed;
        }
    </style>
</head>

<body>
    <h3>
        Leina Li (ll736), Aditya Manthri (anm97)
    </h3>
    <svg id="scattersvg" height="600" width="600"></svg>
    <script>
        const scatsvg = d3.select("svg#scattersvg");
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
        width = scatsvg.attr("width");
        height = scatsvg.attr("height");
        const margins = { top: 50, right: 20, bottom: 70, left: 70 };
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;
        let selectedPoints = [];


        var comparisonDiv = d3.select("body").append("div")
            .attr("class", "comparison")
            .style("opacity", 0);

        var dataset;
        d3.csv('./pokedex.csv', d3.autoType)
            .then((data) => {

                dataset = data;

                yExtent = d3.extent(data, d => d['Total']);
                xExtent = d3.extent(data, d => d['Generation']);
                typeExtent = [];
                data.forEach(function (d) {
                    if (!typeExtent.includes(d['Type I'])) {
                        typeExtent.push(d['Type I']);
                    }
                });
                console.log(typeExtent)

                const typeSelectionDiv = d3.select("#type-selection");
                typeExtent.forEach(function (type) {
                    typeSelectionDiv.append("label")
                        .text(type)
                        .append("input")
                        .attr("type", "checkbox")
                        .attr("name", "type")
                        .attr("value", type)
                        .style("margin-left", "5px")
                        .style("margin-right", "15px");
                });
                yScale = d3.scaleLinear().domain(yExtent).range([chartHeight, 0]);
                xScale = d3.scaleLinear().domain(xExtent).range([0, chartWidth]);
                colors = [
                    "#7AC74C", // Grass
                    "#EE8130", // Fire
                    "#6390F0", // Water
                    "#A6B91A", // Bug
                    "#A8A77A", // Normal
                    "#A33EA1", // Poison
                    "#F7D02C", // Electric
                    "#E2BF65", // Ground
                    "#D685AD", // Fairy
                    "#C22E28", // Fighting
                    "#F95587", // Psychic
                    "#B6A136", // Rock
                    "#735797", // Ghost
                    "#96D9D6", // Ice
                    "#6F35FC", // Dragon
                    "#705746", // Dark
                    "#B7B7CE", // Steel
                    "#A98FF3"  // Flying
                ];
                const typeScale = d3.scaleOrdinal().domain(typeExtent).range(colors);
                let chartArea = scatsvg.append('g')
                    .attr('transform', `translate(${margins.left}, ${margins.top})`);

                let leftAxis = d3.axisLeft(yScale);
                scatsvg.append('g')
                    .attr('class', 'y axis')
                    .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                    .call(leftAxis);

                let bottomAxis = d3.axisBottom(xScale)
                    .tickFormat(d3.format(".0f"))
                    .ticks(9)
                let element = scatsvg.append('g')
                    .attr('class', 'y axis')
                    .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                    .call(bottomAxis);

                let leftGridlines = d3.axisLeft(yScale)
                    .tickSize(-chartWidth - 10)
                    .tickFormat('');
                scatsvg.append('g').attr('class', 'gridlines')
                    .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                    .call(leftGridlines)

                let bottomGridlines = d3.axisBottom(xScale)
                    .tickSize(-chartHeight - 10)
                    .tickFormat('')
                    .ticks(9);
                scatsvg.append('g').attr('class', 'gridlines')
                    .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                    .call(bottomGridlines);

                scatsvg.append("text")
                    .attr("class", "x-axis-title")
                    .attr("x", chartWidth / 2 + 50)
                    .attr("y", chartHeight + 100)
                    .attr("text-anchor", "middle")
                    .text("Generation");


                scatsvg.append("text")
                    .attr("class", "y-axis-title")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -chartHeight / 2 - 50)
                    .attr("y", 20)
                    .attr("text-anchor", "middle")
                    .text("Base Stats Total");

                scatsvg.append("text")
                    .attr("class", "chart-title")
                    .attr("x", chartWidth / 2 + 40)
                    .attr("y", 30)
                    .attr("text-anchor", "middle")
                    .style("font-weight", "bold")
                    .style("font-size", "20px")
                    .style("fill", "black")
                    .text("Change of Pokemon's BST over Pokemon Generations");

                chartArea.selectAll('circle')
                    .data(data)
                    .enter().append('circle')
                    .attr('cx', d => xScale(d['Generation']) + (Math.random() - 0.5) * 10) // Jitter in the X direction
                    .attr('cy', d => yScale(d['Total']))
                    .attr('r', '5px')
                    .attr('opacity', 0.5)
                    .style('fill', function (d) { return typeScale(d['Type I']); })
                    // When setting the position of each circle, add a small random value

                    .on("click", function (event, d) {
                        // Toggle selection logic
                        const index = selectedPoints.findIndex(p => p.Pokemon === d.Pokemon);
                        if (index > -1) {
                            selectedPoints.splice(index, 1); // Deselect if already selected
                            d3.select(this)
                                .attr("r", "5px")
                                .attr("opacity", 0.5)
                                .style('stroke', 'none');
                        } else {
                            if (selectedPoints.length < 2) {
                                selectedPoints.push(d); // Select if not already selected and less than 2 selected
                                d3.select(this)
                                    .attr("r", "15px")
                                    .attr("opacity", 0.8)
                                    .style('stroke', 'black')
                                    .style('stroke-width', 3);
                            }
                        }

                        // Display comparison if two points are selected
                        if (selectedPoints.length === 2) {
                            let comparisonHtml = "Comparison:<br/>";
                            // Generate comparison content
                            comparisonHtml += `<strong>${selectedPoints[0].Pokemon}</strong> vs <strong>${selectedPoints[1].Pokemon}</strong><br/>`;
                            // Add more details as needed
                            comparisonDiv.html(comparisonHtml)
                                .style("opacity", 1)
                                .style("position", "fixed")
                                .style("bottom", "20px")
                                .style("left", "20px")
                                .style("background-color", "white")
                                .style("padding", "10px")
                                .style("border", "1px solid black")
                                .style("border-radius", "8px");
                        } else {
                            comparisonDiv.style("opacity", 0);
                        }

                    })

                    .on("mouseover", showTooltip)

                    .on("mouseout", unshowtooltip);

                d3.selectAll("#type-selection input[type='checkbox'], #filter-mode input[type='radio']")
                    .on("change", function () {
                        updateChart();
                    });
                //start of page want it disabled;
                d3.selectAll("#type-selection input[type='checkbox']")
                    .property('disabled', true);

                function updateChart() {
                    const selectedTypes = d3.selectAll("#type-selection input[type='checkbox']:checked").nodes().map(el => el.value);
                    const filterMode = d3.select("#filter-mode input[type='radio']:checked").node().value;

                    let filteredData;
                    if (filterMode === "or") {
                        d3.selectAll("#type-selection input[type='checkbox']").property('disabled', false);
                        filteredData = dataset.filter(d => selectedTypes.includes(d['Type I']) || selectedTypes.includes(d['Type II']));
                    } else if (filterMode === "and") {
                        d3.selectAll("#type-selection input[type='checkbox']").property('disabled', false);
                        if (selectedTypes.length === 0) {
                            // Show nothin
                            filteredData = {};
                        } else if (selectedTypes.length === 1) {
                            // Show data where either 'Type I' or 'Type II' matches the selected type
                            filteredData = dataset.filter(d => selectedTypes.includes(d['Type I']) || selectedTypes.includes(d['Type II']));
                        } else {
                            // Show data where both 'Type I' and 'Type II' match the selected types
                            filteredData = dataset.filter(d => selectedTypes.includes(d['Type I']) && selectedTypes.includes(d['Type II']));
                        }
                    } else if (filterMode === "all") {
                        d3.selectAll("#type-selection input[type='checkbox']").property('disabled', true);
                        filteredData = dataset;
                    }

                    // Bind filtered data to circles
                    const circles = chartArea.selectAll("circle")
                        .data(filteredData, d => d.Pokemon); // Use Pokemon name as a key for object constancy

                    // Enter selection: Create new circles for new data elements
                    circles.enter().append("circle")
                        .attr('cx', d => xScale(d['Generation']) + (Math.random() - 0.5) * 20) // Apply jittering if needed
                        .attr('cy', d => yScale(d['Total']) + (Math.random() - 0.5) * 20)
                        .attr('r', d => {
                            const isSelected = selectedPoints.some(p => p.Pokemon === d.Pokemon);
                            return isSelected ? 15 : 5;
                        })
                        .style('stroke', d => {
                            const isSelected = selectedPoints.some(p => p.Pokemon === d.Pokemon);
                            return isSelected ? 'black' : 'none'
                        })
                        .style('stroke-width', 3)
                        .attr('opacity', d => {
                            const isSelected = selectedPoints.some(p => p.Pokemon === d.Pokemon);
                            return isSelected ? 0.8 : 0.5
                        })
                        .style('fill', d => typeScale(d['Type I']))
                        .merge(circles) // Merge enter and update selections
                        .on("mouseover", showTooltip)
                        .on("mouseout", unshowtooltip)
                        .on("click", function (event, d) {

                            //// TOGGLE
                            const index = selectedPoints.findIndex(p => p.Pokemon === d.Pokemon);
                            if (index > -1) {
                                selectedPoints.splice(index, 1); // Deselect if already selected
                                d3.select(this)
                                    .attr("r", "5px")
                                    .attr("opacity", 0.5)
                                    .style('stroke', 'none');
                            } else {
                                if (selectedPoints.length < 2) {
                                    selectedPoints.push(d); // Select if not already selected and less than 2 selected
                                    d3.select(this)
                                        .attr("r", "15px")
                                        .attr("opacity", 0.8)
                                        .style('stroke', 'black')
                                        .style('stroke-width', 3);
                                }
                            }

                            // Display comparison if two points are selected
                            if (selectedPoints.length === 2) {
                                let comparisonHtml = "Comparison:<br/>";
                                // Generate comparison content
                                comparisonHtml += `<strong>${selectedPoints[0].Pokemon}</strong> vs <strong>${selectedPoints[1].Pokemon}</strong><br/>`;
                                // Add more details as needed
                                comparisonDiv.html(comparisonHtml)
                                    .style("opacity", 1)
                                    .style("position", "fixed")
                                    .style("bottom", "20px")
                                    .style("left", "20px")
                                    .style("background-color", "white")
                                    .style("padding", "10px")
                                    .style("border", "1px solid black")
                                    .style("border-radius", "8px");
                            } else {
                                comparisonDiv.style("opacity", 0);
                            }
                        });

                    // Update selection: Update attributes of existing circles
                    circles
                        .attr('cx', d => xScale(d['Generation']) + (Math.random() - 0.5) * 20)
                        .attr('cy', d => yScale(d['Total']) + (Math.random() - 0.5) * 20)
                        .style('fill', d => typeScale(d['Type I'])); // If you want to update the fill based on the filter

                    // Exit selection: Remove circles that no longer match the filter
                    circles.exit().remove();
                }

                function showTooltip(event, d) {
                    // Define stats and maximum value for scaling the bars
                    const stats = [
                        { name: 'HP', value: d['HP'] },
                        { name: 'Attack', value: d['Atk'] },
                        { name: 'Defense', value: d['Def'] },
                        { name: 'Sp. Atk', value: d['SpA'] },
                        { name: 'Sp. Def', value: d['SpD'] },
                        { name: 'Speed', value: d['Spe'] }
                    ];
                    const maxStatValue = 255;

                    // Convert Pokémon name to match the URL format (assuming names are already standardized in your dataset)
                    let pokemonNameForUrl = d['Pokemon'].toLowerCase().replace(/ /g, '-');

                    // Construct the sprite URL
                    let spriteUrl = `https://img.pokemondb.net/sprites/home/normal/${pokemonNameForUrl}.png`;

                    // Start building the tooltip content with Pokémon name, types, and sprite
                    let tooltipHtml = `<strong>${d['Pokemon']}</strong><br/>
                                                    <img src="${spriteUrl}" alt="${d['Pokemon']}" style="width:100px; height:100px;"><br/>
                                                    Type: ${d['Type I']}` + (d['Type II'] ? `, ${d['Type II']}` : "") + `<br/>`;


                    // Add an SVG container for the stats bar chart
                    tooltipHtml += `<svg width="200" height="${stats.length * 20}" xmlns="http://www.w3.org/2000/svg">`;

                    // Generate bars for each stat
                    stats.forEach((stat, index) => {
                        const barWidth = (stat.value / maxStatValue) * 180; // Scale bar width
                        tooltipHtml += `<text x="0" y="${index * 20 + 15}" font-size="10">${stat.name}</text>`;
                        tooltipHtml += `<rect x="50" y="${index * 20 + 10}" width="${barWidth}" height="10" style="fill:steelblue;"></rect>`;
                        tooltipHtml += `<text x="${barWidth + 55}" y="${index * 20 + 15}" font-size="10">${stat.value}</text>`;
                    });

                    tooltipHtml += `</svg>`;

                    // Display the tooltip
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(tooltipHtml)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");

                    console.log(selectedPoints)
                    // console.log(this)
                    if (!selectedPoints.includes(d)) {
                        d3.select(this)
                            .attr("opacity", 1)
                            .attr("r", "8px")
                            .style('stroke', 'black')
                            .style('stroke-width', 3);
                    }
                }

                function unshowtooltip(event, d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                    if (!selectedPoints.includes(d)) {
                        d3.select(this)
                            .attr("r", "5px")
                            .attr("opacity", 0.5)
                            .style('stroke', "none")
                    }
                }

                chartArea.raise()

            });

    </script>
</body>

</html>